{"title": "Software for computing and annotating genomic ranges", "pubDate": "2013;9(8):e1003118.", "PMCID": "PMC3738458", "DOI": "10.1371/journal.pcbi.1003118", "PMID": "23950696", "abstract": "We describe Bioconductor infrastructure for representing and computing on annotated genomic ranges and integrating genomic data with the statistical computing features of R and its extensions. At the core of the infrastructure are three packages: IRanges, GenomicRanges, and GenomicFeatures. These packages provide scalable data structures for representing annotated ranges on the genome, with special support for transcript structures, read alignments and coverage vectors. Computational facilities include efficient algorithms for overlap and nearest neighbor detection, coverage calculation and other range operations. This infrastructure directly supports more than 80 other Bioconductor packages, including those for sequence analysis, differential expression analysis and visualization.", "author": [{"author": "Michael Lawrence", "affiliation": ["Bioinformatics and Computational Biology, Genentech, Inc., South San Francisco, California, United States of America. michafla@gene.com"], "href": "/?term=Lawrence+M&cauthor_id=23950696"}, {"author": "Wolfgang Huber", "affiliation": [], "href": "/?term=Huber+W&cauthor_id=23950696"}, {"author": "Herv\u00e9 Pag\u00e8s", "affiliation": [], "href": "/?term=Pag%C3%A8s+H&cauthor_id=23950696"}, {"author": "Patrick Aboyoun", "affiliation": [], "href": "/?term=Aboyoun+P&cauthor_id=23950696"}, {"author": "Marc Carlson", "affiliation": [], "href": "/?term=Carlson+M&cauthor_id=23950696"}, {"author": "Robert Gentleman", "affiliation": [], "href": "/?term=Gentleman+R&cauthor_id=23950696"}, {"author": "Martin T Morgan", "affiliation": [], "href": "/?term=Morgan+MT&cauthor_id=23950696"}, {"author": "Vincent J Carey", "affiliation": [], "href": "/?term=Carey+VJ&cauthor_id=23950696"}], "refPMID": ["15461798", "20110278", "18978777", "18714091", "19654119", "19096707", "20299549", "20147302", "19468054"], "citedInPMID": ["23950696", "35154177", "35127291", "35123506", "35121978", "35087229", "35087209", "35083215", "35082832", "35075108", "35064145", "35058465", "35055008", "35049501", "35039061", "35037220", "35029648", "35013207", "35012466", "35009106", "34986603", "34984327", "34977215", "34973146", "34956186", "34952892", "34939924", "34922620", "34907913", "34895143", "34883507", "34882763", "34880900", "34880491", "34880131", "34877933", "34876166", "34873462", "34858848", "34851738", "34845392", "34845251", "34844637", "34843592", "34838024", "34794168", "34788628", "34782724", "34780285", "34754626", "34752747", "34739872", "34731638", "34731626", "34730997", "34728774", "34725151", "34719687", "34707916", "34695109", "34681702", "34680891", "34680890", "34675930", "34667177", "34666004", "34648488", "34634038", "34633447", "34616072", "34616067", "34616066", "34592154", "34591015", "34580351", "34570758", "34565452", "34559986", "34530905", "34528512", "34514416", "34507984", "34504875", "34503185", "34499218", "34497619", "34493870", "34493869", "34489976", "34467232", "34465585", "34450044", "34446533", "34439083", "34431104", "34429407", "34429136", "34428301", "34428294", "34425882", "34424154", "34419158", "34416157", "34415926", "34408135", "34406159", "34397140", "34394053", "34387544", "34382191", "34367159", "34353948", "34353365", "34344431", "34337766", "34326481", "34319975", "34298922", "34294889", "34292313", "34290257", "34288360", "34284724", "34283254", "34282330", "34276305", "34273980", "34267208", "34250478", "34249082", "34245124", "34244513", "34238961", "34235431", "34234345", "34232857", "34220851", "34195962", "34189474", "34183059", "34182919", "34174819", "34172835", "34168039", "34162876", "34156292", "34154423", "34149803", "34147079", "34147068", "34146095", "34145397", "34144391", "34128467", "34128466", "34127518", "34127050", "34126923", "34120004", "34113819", "34111399", "34108989", "34108012", "34107263", "34103073", "34099702", "34069681", "34068493", "34063040", "34059643", "34058980", "34054419", "34050142", "34050140", "34044854", "34039950", "34031415", "34020942", "34016968", "34004146", "34001004", "33998604", "33992677", "33982759", "33982016", "33976151", "33974080", "33961804", "33959723", "33952325", "33947435", "33941934", "33941616", "33930021", "33926515", "33924915", "33923758", "33923150", "33918448", "33911282", "33910930", "33909924", "33905460", "33903764", "33902445", "33900608", "33900588", "33893285", "33888138", "33886505", "33879525", "33879496", "33875642", "33871647", "33869207", "33863790", "33861994", "33859404", "33859189", "33850256", "33850148", "33850129", "33849458", "33848268", "33846331", "33846320", "33845768", "33839688", "33838102", "33837008", "33835440", "33835024", "33828098", "33827905", "33824960", "33824350", "33821005", "33801838", "33789351", "33789083", "33771997", "33764853", "33762588", "33751124", "33741065", "33731366", "33722934", "33720012", "33719335", "33693880", "33693822", "33683369", "33673003", "33672117", "33664406", "33663384", "33658518", "33654857", "33653267", "33647456", "33637722", "33631799", "33627377", "33619380", "33602827", "33599103", "33597573", "33591952", "33589631", "33582756", "33575621", "33568206", "33567280", "33563825", "33558757", "33555315", "33555055", "33539279", "33536639", "33529646", "33529205", "33514403", "33510161", "33509101", "33500731", "33488665", "33488615", "33483494", "33482892", "33472617", "33471819", "33465077", "33462210", "33460396", "33454011", "33453134", "33446014", "33445503", "33443214", "33439114", "33432081", "33428615", "33413102", "33410399", "33396256", "33391824", "33378328", "33361335", "33357452", "33352108", "33349665", "33339161", "33337321", "33331123", "33327530", "33326110", "33317406", "33315856", "33296649", "33293651", "33290556", "33288854", "33288765", "33273683", "33261552", "33251203", "33243990", "33241976", "33239669", "33233382", "33219570", "33216727", "33213377", "33193703", "33192586", "33186530", "33186072", "33185185", "33177523", "33176148", "33172971", "33169629", "33158963", "33149148", "33144602", "33139882", "33139741", "33122634", "33108356", "33106540", "33101353", "33098766", "33092522", "33087928", "33077858", "33075803", "33073674", "33067514", "33048947", "33046896", "33035207", "33031487", "33030396", "33024035", "33022046", "33020268", "33010822", "33006196", "33004976", "33004416", "33002421", "33001029", "32989154", "32977850", "32976578", "32967372", "32967096", "32956417", "32943640", "32937138", "32917133", "32912294", "32908306", "32900804", "32898151", "32895530", "32888433", "32875100", "32871001", "32867538", "32859263", "32854615", "32851977", "32851975", "32850851", "32846140", "32845239", "32842972", "32841603", "32831172", "32824688", "32821938", "32817010", "32814038", "32807776", "32791885", "32788728", "32788376", "32778826", "32778653", "32773032", "32769162", "32767663", "32756002", "32753692", "32747411", "32732264", "32728612", "32728031", "32727924", "32710622", "32709717", "32707835", "32703790", "32699630", "32695786", "32692442", "32679107", "32669333", "32665844", "32662873", "32656317", "32650490", "32646368", "32641141", "32633672", "32631399", "32628663", "32616653", "32610501", "32601068", "32596474", "32582287", "32580154", "32579585", "32577654", "32573705", "32570879", "32565674", "32561899", "32553182", "32531054", "32528659", "32527045", "32518223", "32512748", "32502192", "32500038", "32498674", "32496553", "32492250", "32490812", "32487212", "32483326", "32467243", "32460015", "32450900", "32438745", "32429868", "32429430", "32418995", "32413978", "32410960", "32407006", "32405063", "32392348", "32382395", "32377445", "32376862", "32375885", "32354704", "32353066", "32347792", "32338593", "32331491", "32321915", "32320644", "32292070", "32290757", "32287290", "32275679", "32271875", "32253515", "32251359", "32228449", "32227215", "32226440", "32219510", "32219167", "32213639", "32206710", "32204435", "32198348", "32182340", "32174978", "32165618", "32164620", "32162327", "32160291", "32142654", "32142631", "32133535", "32127543", "32123177", "32109204", "32107550", "32106218", "32103242", "32098967", "32097405", "32094342", "32094114", "32089544", "32080885", "32079618", "32079323", "32075560", "32075553", "32071080", "32068945", "32061128", "32051931", "32032585", "32015324", "32003788", "32002328", "31998359", "31996894", "31993082", "31968256", "31953534", "31937828", "31934860", "31932695", "31930715", "31924161", "31919189", "31919188", "31915390", "31915147", "31911579", "31908268", "31906249", "31903447", "31901106", "31894455", "31882844", "31877125", "31873292", "31870811", "31870409", "31862408", "31860442", "31852722", "31850594", "31850058", "31840183", "31824778", "31822509", "31822279", "31820119", "31820086", "31819221", "31806013", "31805521", "31802126", "31797920", "31794382", "31792435", "31782544", "31781178", "31768072", "31767860", "31746740", "31745090", "31739806", "31731552", "31731486", "31729981", "31722199", "31710657", "31704928", "31703553", "31699975", "31699777", "31699133", "31694866", "31665646", "31665443", "31665434", "31652272", "31647412", "31645947", "31644907", "31641075", "31626771", "31625833", "31619466", "31616467", "31585526", "31583464", "31578350", "31575636", "31568516", "31554806", "31551426", "31548855", "31548705", "31546687", "31532761", "31525177", "31523126", "31519798", "31515279", "31510685", "31509757", "31506062", "31506003", "31501259", "31500805", "31496026", "31492745", "31465303", "31439880", "31435019", "31433991", "31431618", "31409695", "31399544", "31398226", "31392276", "31392275", "31391555", "31391303", "31390359", "31387530", "31387525", "31384394", "31379928", "31379474", "31366910", "31363093", "31361600", "31353404", "31351877", "31350345", "31350272", "31341168", "31327999", "31320617", "31316208", "31305886", "31300558", "31294478", "31292548", "31263277", "31262215", "31253077", "31251375", "31249304", "31248964", "31248380", "31240103", "31238884", "31227770", "31216473", "31216042", "31204013", "31201210", "31198831", "31189880", "31182025", "31168651", "31167636", "31159833", "31147718", "31142573", "31127176", "31118054", "31117935", "31113899", "31113823", "31090539", "31076359", "31058972", "31058278", "31051141", "31046658", "31042469", "31041520", "31040210", "31033435", "31023523", "31011208", "31010886", "30993345", "30979659", "30976116", "30973881", "30967549", "30967537", "30959515", "30955436", "30952851", "30948807", "30943101", "30940089", "30918514", "30911095", "30910813", "30906313", "30905091", "30897342", "30894586", "30888319", "30885941", "30875926", "30867528", "30865623", "30862609", "30858613", "30850588", "30850374", "30847478", "30840074", "30833353", "30828568", "30828438", "30824702", "30814732", "30808286", "30806032", "30805613", "30804403", "30803482", "30796839", "30793194", "30781862", "30769946", "30765700", "30760496", "30753588", "30734197", "30723574", "30718424", "30698741", "30692544", "30689724", "30679435", "30679259", "30670485", "30668641", "30664750", "30660039", "30658577", "30651361", "30643296", "30639241", "30639098", "30630522", "30629588", "30622105", "30618377", "30609939", "30586455", "30583723", "30577750", "30573454", "30566651", "30548709", "30541149", "30540963", "30530468", "30526479", "30519242", "30514929", "30454561", "30452449", "30445760", "30445574", "30445487", "30423059", "30409965", "30384843", "30382198", "30377227", "30374110", "30352805", "30349559", "30349032", "30343898", "30343665", "30341162", "30327463", "30307532", "30305606", "30301757", "30297425", "30285865", "30279501", "30279468", "30277498", "30271999", "30242156", "30239796", "30239706", "30232138", "30224337", "30223795", "30222580", "30211673", "30210482", "30202060", "30186296", "30184510", "30154823", "30150662", "30134157", "30120223", "30111569", "30104565", "30087365", "30087163", "30086749", "30085031", "30082830", "30075130", "30071827", "30059966", "30049682", "30046334", "30033119", "30018130", "30013979", "30009162", "30005604", "30001693", "29995890", "29986055", "29985951", "29963233", "29958539", "29941091", "29940860", "29928511", "29922260", "29914890", "29909776", "29906450", "29891877", "29878235", "29876699", "29876646", "29875488", "29875134", "29867230", "29860503", "29858012", "29856883", "29848443", "29806020", "29805765", "29801521", "29793448", "29782654", "29782489", "29778830", "29773832", "29765016", "29740534", "29730990", "29716618", "29712937", "29712907", "29712777", "29703149", "29695279", "29682207", "29677183", "29669274", "29666160", "29636374", "29636009", "29618800", "29618320", "29605852", "29599752", "29578408", "29567659", "29562236", "29549885", "29545468", "29517993", "29517944", "29490630", "29483650", "29476074", "29460983", "29458328", "29438994", "29402885", "29396410", "29391490", "29383100", "29373955", "29371594", "29368659", "29361907", "29360433", "29343938", "29329372", "29325072", "29316219", "29307494", "29300744", "29298683", "29288200", "29282329", "29275859", "29267285", "29263307", "29234016", "29233099", "29202200", "29186125", "29180763", "29156688", "29155828", "29150689", "29126155", "29115931", "29093522", "29093179", "29092936", "29091716", "29084208", "29083321", "29070071", "29065907", "29059365", "29059320", "29043067", "29028941", "29028267", "29028265", "29017058", "28984183", "28977995", "28977666", "28974674", "28973853", "28967912", "28945883", "28945760", "28924262", "28919886", "28916722", "28900227", "28891464", "28886108", "28877255", "28855307", "28847918", "28830561", "28811507", "28784182", "28783698", "28751969", "28751729", "28742980", "28720766", "28698046", "28694385", "28679547", "28679546", "28678605", "28671352", "28655788", "28653111", "28615362", "28604729", "28604674", "28581511", "28581502", "28569140", "28562671", "28536147", "28514453", "28513600", "28510608", "28506212", "28500049", "28487311", "28485712", "28483910", "28481340", "28475575", "28448736", "28446146", "28436936", "28424687", "28423700", "28416184", "28401939", "28400492", "28381557", "28369036", "28367077", "28364390", "28359302", "28351647", "28346506", "28344039", "28341771", "28334930", "28334390", "28334349", "28321697", "28314795", "28301596", "28298479", "28295365", "28288095", "28286470", "28273136", "28270558", "28264512", "28263325", "28263295", "28262799", "28252016", "28235418", "28234977", "28231763", "28223504", "28215706", "28213356", "28195208", "28193893", "28180286", "28166212", "28126037", "28115490", "28112643", "28102191", "28097054", "28089908", "28061857", "28056037", "28054346", "28049421", "28027312", "28018047", "28008155", "27999613", "27999612", "27993167", "27989769", "27982126", "27981238", "27980682", "27966532", "27964755", "27940919", "27923844", "27903907", "27903902", "27899585", "27892456", "27881411", "27881084", "27879204", "27876851", "27864587", "27814717", "27799065", "27791167", "27783602", "27757989", "27698416", "27694310", "27686863", "27681124", "27669167", "27665711", "27650223", "27646533", "27641360", "27633323", "27625398", "27576189", "27576083", "27538250", "27528462", "27515738", "27512997", "27510891", "27504829", "27500631", "27500525", "27499173", "27487213", "27477909", "27476966", "27473283", "27472961", "27404876", "27381916", "27363486", "27354857", "27351973", "27341628", "27336699", "27333864", "27322251", "27317696", "27315794", "27303926", "27302131", "27296936", "27291689", "27260404", "27257071", "27249108", "27245778", "27239475", "27235415", "27218464", "27208254", "27195021", "27189775", "27189211", "27185157", "27183995", "27137890", "27100738", "27082926", "27072894", "27071505", "27068107", "27041075", "27014338", "27001520", "26982580", "26977414", "26963711", "26926995", "26923702", "26910913", "26907635", "26903634", "26891448", "26878062", "26822956", "26818886", "26791998", "26786711", "26764273", "26726773", "26704973", "26700097", "26692141", "26689968", "26674615", "26673711", "26670385", "26668394", "26657539", "26637433", "26623667", "26621857", "26609224", "26602609", "26598390", "26576536", "26575221", "26569124", "26523646", "26523118", "26512062", "26508757", "26484284", "26463000", "26433228", "26424858", "26415965", "26390058", "26339299", "26334759", "26290536", "26290394", "26261339", "26253700", "26201343", "26196144", "26187896", "26134322", "26129908", "26091879", "26066343", "26066318", "26034064", "26016777", "26008846", "26005864", "25994056", "25972926", "25972895", "25961935", "25959060", "25926345", "25924931", "25903198", "25883320", "25847947", "25805732", "25776870", "25748651", "25651398", "25639469", "25633503", "25607372", "25516281", "25417205", "25410209", "25370990", "25364758", "25288800", "25260792", "25260700", "25236859", "25150837", "25149281", "25086505", "25026199", "25007794", "24995333", "24868015", "24847061", "24759320", "24681907", "24489369", "24286512", "24278031", "24058055"], "body": " AbstractWe describe Bioconductor infrastructure for representing and computing on annotated genomic ranges and integrating genomic data with the statistical computing features of R and its extensions. At the core of the infrastructure are three packages: IRanges, GenomicRanges, and GenomicFeatures. These packages provide scalable data structures for representing annotated ranges on the genome, with special support for transcript structures, read alignments and coverage vectors. Computational facilities include efficient algorithms for overlap and nearest neighbor detection, coverage calculation and other range operations. This infrastructure directly supports more than 80 other Bioconductor packages, including those for sequence analysis, differential expression analysis and visualization. This is a PLOS Computational Biology Software Article. IntroductionThe genome is typically represented as a linear sequence, split over multiple chromosomes, and data are linked to the genome by occupying a range of positions on the sequence. These data fall into two broad categories. First, there are the annotations, such as gene models, transcription factor binding site predictions, GC percentage, polymorphisms, and conservation scores. Such annotations are highly processed and are often served by public databases such as NCBI or EBI. Second, there are primary experimental measurements, such as read alignments from high-throughput sequencing. Data integration, within and between those two categories, is made possible by treating the data as ranges on the genome, which acts as a common scaffold. Thus, ranges play a central role in genomic data analysis, and statistical tools should consider ranges to be as fundamental as quantitative and categorical data types.For example, ranges are integral to the manipulation of gene model annotations. Examples include deriving candidate promoter regions, finding introns, calculating the total exonic length of a transcript or finding the exonic regions that are unique to a particular transcript in an alternatively spliced gene. Ranges also play a central role in the analysis of experimental data, where they are used to represent read alignments. In the analysis of ChIP-seq data, it is typical to calculate the depth of alignment coverage, which then serves as input to calling algorithms which output peaks as ranges. These ranges are then annotated according to their overlap with and proximity to other ranges, such as gene structures. Similarly, for RNA-seq data, analysts measure gene expression based on counting the alignments overlapping exons.All these analyses depend on specialized, range-based algorithms and data structures. For example, computations on gene models involve set operations on ranges, including intersection, union and complement. Coverage calculation is important for detecting regions of enrichment and for producing visual summaries. Overlap and nearest neighbor detection is fundamental to the annotation of ChIP-seq peaks, estimating expression from RNA-seq data and many other integrative analyses.The primary argument for storing ranges in specialized, formal data structures is efficiency, in terms of both implementation and language. The notion of ranges can be made explicit in the application programming interface (API), permitting the expression of algorithms in a succinct and readable language that illustrates concepts instead of exposing implementation details. Another goal is interoperability: by using the same data structures, multiple routines, spread across different packages, can operate on the data without cumbersome conversions. Also, a data structure can be accessed through an abstraction that hides the details of the optimized implementation, and this results in looser coupling between components. Together, these benefits lead to more robust, maintainable software.Data structures should support the storage of per-range metadata, because genomic data is multivariate and consists of much more than the ranges alone. This enables the storage of gene identifiers and other symbols with the gene ranges, and the peak heights or confidence scores with the peak ranges. Some metadata merit special treatment, such as the chromosome name and the strand. Also necessary is a data structure for storing summaries and processing results for a common set of ranges across multiple samples. Such a structure would hold, for example, the RNA-seq per-exon counts or a set of variant calls. Finally, there should be support for storing hierarchies of ranges, at least for one level of nesting, to represent, for example, the nesting of exons into transcripts. Whether it is appropriate to treat the exons as individual ranges or the transcript as a compound range depends on the use case; both should be supported.These data structures are represented as classes, through which we communicate the formal definition of each data structure to the programming language. One benefit is that we can defer the regulation of data access and the tracking of data integrity to the language. In the case of functional object-oriented languages, there is another benefit: we can implement behaviors as methods on generic functions. A generic function is one that dispatches to a particular implementation, termed a method, based on the classes of passed arguments. This means that the same API will exhibit specialized behavior depending on the input. For example calling start on a range data structure would return the starting positions for the ranges, while calling the same function on a base R time-series object would behave differently.This paper describes the infrastructure in Bioconductor [1] for the integrative statistical analysis of range-based genomic data. Main features include scalable data structures for annotated genomic ranges and genome-length vectors, and efficient algorithms for overlap detection and other range operations. The packages that form the core of the infrastructure include IRanges, GenomicRanges and GenomicFeatures. Source code for the packages is included in the supplement, under Software S1, S2, and S3, respectively. The IRanges package provides the fundamental range data structures and operations, while GenomicRanges builds upon it to add biological semantics to the metadata, including explicit treatment of sequence name and strand. Finally, GenomicFeatures enables access to and manipulation of gene models and other annotations. Together, these packages support more than 80 other packages in Bioconductor.Other software tools provide facilities for working with genomic ranges, e.g., bedtools\n[2] and cisGenome\n[3]. Those provide UNIX command-line interfaces and rely on common file formats (which are often incompletely specified) to interoperate with other tools, leading to workflows embodied as: collections of heterogeneous scripts, system dependencies and data files. Such workflows can be difficult to maintain and challenging to reproduce. In contrast, the Bioconductor infrastructure is tightly integrated with other R packages through in-memory data structures, while still supporting interaction with external tools. The Bioconductor package genomeIntervals provides data structures for representing genomic ranges and utilities, such as overlap detection, that have much in common with the tools described here, but our tools are more extensive and have been more widely adopted. Design and ImplementationWorking with Simple RangesWe use the term \u201crange\u201d to denote an ordered set of consecutive integers. A range is represented by a pair of integers  satisfying . In Figure 1,  and  correspond to the start and end columns, respectively. The \u201cwidth\u201d of a range is given by , so a range for a single integer (modeling, for example, a single nucleotide position) has .Open in a separate windowFigure 1Tabular (top) and visual (bottom) representation of the exons for the human KRAS gene, derived from the UCSC known gene annotation.In the table, the columns seqnames, start and end locate the exons in the genome. The strand column indicates the direction of transcription. The exons are grouped into transcripts by tx_id, and the exon IDs are given by exon_id. Virtually all genomic data sets fit this pattern: genomic location, followed by a series of columns, often including strand and/or score, that annotate that location. In the plot, the rectangles represent exonic regions, and the arrows represent the introns, as well as the strand.The IRanges package, which is designed to be general and thus avoids biology-specific considerations, introduces the IRanges class to represent a vector of ranges. The GenomicRanges package builds on IRanges to include biologically relevant features such as strand and sequence (e.g., chromosome) name.In Figure 1, we show a table of the exons of the human gene KRAS. The tx_id column indicates the transcripts to which each exon belongs. A single IRanges object can store those exon ranges, and this model is appropriate for per-exon analyses.The IRanges class supports the basic R vector API, including the length accessor, extraction and subsetting functions like [[ and [ , concatenation with c, etc. This will hold true for all vector-like objects in the range infrastructure.The available range operations are listed in Table 1. The IRanges object supports direct manipulation of the start, end and width of the contained ranges. In applications, many of these operations follow recurrent patterns, and manipulating start and end directly can be needlessly tedious and error-prone. For this reason, shift, resize and similar frequently useful range operations are provided. Ranges can be simplified and summarized with several functions, including range, reduce and disjoin. Figure 2 illustrates the latter two. It is often appropriate to conceive of an IRanges object as a mathematical set of integers, or, in the biological context, a set of nucleotide positions. gaps (complement), union, intersect and setdiff support this notion. For example, taking the union of two transcripts would yield the ranges covered by any KRAS exon. The flank function could be used to demarcate putative promoter regions of transcripts.Open in a separate windowFigure 2Illustration of the reduce and disjoin operations on the last exon from each of the KRAS transcripts.Table 1Summary of the Ranges API.CategoryFunctionDescriptionAccessors\nstart, end, width\nGet or set the starts, ends and widths\nnames\nGet or set the names\nelementMetadata, metadata\nGet or set metadata on elements or object\nlength\nNumber of ranges in the vector\nrange\nRange formed from min(start) and max(end)Ordering\n<, <\u200a=\u200a, >, >\u200a=\u200a, \u200a=\u200a\u200a=\u200a, !\u200a=\u200a\nCompare ranges, ordering by start then width\nsort, order, rank\nSort by the ordering defined above\nduplicated\nFind ranges with multiple instances\nunique\nFind unique instances, removing duplicatesArithmetic\nr+x, r\u2212x, r * x\nShrink or expand ranges r by number x\n\nshift\nMove the ranges by specified amount\nresize\nChange width, anchoring on start, end or mid\ndistance\nSeparation between ranges (closest endpoints)\nrestrict\nClamp ranges to within some start and end\nflank\nGenerate adjacent regions on start or endSet operations\nreduce\nMerge overlapping and adjacent ranges\nintersect, union, setdiff\nSet operations on reduced ranges\npintersect, punion, psetdiff\nParallel set operations, on each x[i], y[i]\n\ngaps, pgap\nFind regions not covered by reduced ranges\ndisjoin\nRanges formed from union of endpointsOverlaps\nfindOverlaps\nFind all overlaps for each x in y\n\ncountOverlaps\nCount overlaps of each x range in y\n\nnearest\nFind nearest neighbors (closest endpoints)\nprecede, follow\nFind nearest y that x precedes or follows\nx %in% y\nFind ranges in x that overlap range in y\nCoverage\ncoverage\nCount ranges covering each positionExtraction\nr[i]\nGet or set by logical or numeric index\nr[[i]]\nGet integer sequence from start[i] to end[i]\n\nsubsetByOverlaps\nSubset x for those that overlap in y\n\nhead, tail, rev, rep\nConventional R semanticsSplit, combine\nsplit\nSplit ranges by a factor into a RangesList\n\nc\nConcatenate two or more range objectsOpen in a separate windowCategorized listing and description of the API for range-based objects, such as IRanges, RangesList, GRanges and GRangesList.A recurrent operation is overlap detection; various instances are illustrated in Figure 3. In later sections, we apply overlap counting for finding the percentage of ChIP-seq peaks that overlap a promoter, counting the number of RNA-seq reads for each transcript, and other tasks. The findOverlaps function uses an efficient interval tree algorithm [4] to detect overlaps between two IRanges objects, as well as the more complex range-based data structures introduced later. The algorithm supports several types of overlap, including those defined by Allen's Interval Algebra [5]. The one-time cost of constructing the interval tree is , and queries are performed in logarithmic time. In accordance with the vectorized semantics of R, if multiple queries are submitted, they are efficiently processed in batch, without restarting at the root of the tree for each query. The language of implementation is C, which avoids the potentially expensive iteration over the tree in R.Open in a separate windowFigure 3Illustration of overlap (top) and adjacency (bottom) relationships.The any mode detects hits with partial or complete overlap, while within requires that the query range represents a subregion of the subject range.Working with Genomic RangesThe IRanges class encodes only the start and end of ranges but not the chromosome, strand nor other information that is important in genomic applications. The GenomicRanges package adds biological semantics on top of IRanges. At its core is the GRanges class. Each element of a GRanges instance includes a chromosome identifier and strand designation. Each data set is associated with a particular, versioned reference genome sequence consisting of a discrete set of chromosomes or contigs, along with their lengths, if known. The GRanges class thus fully represents the data in Figure 1, and encourages best-practices (e.g., tracking genome build) to minimize book-keeping errors.The GRanges class supports many of the same range operations as IRanges and specializes them for genomic data. We achieved API specialization by implementing methods for both classes on the same generic functions. In general, we believe method specialization is an effective practice for providing the same interface on top of different data structures. Abstracting implementation details leads to user code that is more robust and easier to write and maintain.The GRanges methods give special consideration to the chromosome and, when appropriate, the strand. For instance, the findOverlaps generic has methods for both IRanges and GRanges, and the GRanges method is specifically able to take advantage of the chromosome information when detecting overlaps. Operations that depend on a notion of direction optionally consider strand. For example, the resize function will resize from the start or end of the ranges in a IRanges object. For a GRanges object, resize will take the start to be the leftmost position for positive strand features and the rightmost position for negative strand features.Some types of genomic data, for example gene models or aligned paired-end reads, have a hierarchical structure. To represent this, multiple GRanges objects may be combined into a GRangesList, where each GRanges is considered a compound feature. GRangesList groups transcripts by gene, groups exons by transcript, and represents read alignments, where each alignment consists of multiple segments separated by gaps. For example, we group the KRAS exons by transcript using a GRangesList. A note on performance: although the user interface presents each element of a GRangesList as a GRanges , internally there is only a single GRanges, along with an assoicated partitioning that forms the list elements.For a GRangesList, overlap detection reports a hit at the element level, i.e., when any range within an element overlaps a query range. See Figure 4 for an illustration. This semantic is convenient, for example, when counting the total number of RNA-seq read pairs overlapping the exonic regions of each transcript. In that case, both the reads and the transcripts are GRangesList objects.Open in a separate windowFigure 4Illustration of overlap computations between two GRangesList objects.Each set of rectangles linked by solid lines represents a compound range, i.e., an element of the list. Ranges in the query (top) are being matched against ranges in the subject (bottom). The labels between them indicate the type of overlap (any, within, none).Accessing Gene ModelsRecalling our KRAS gene model example, there are multiple models for representing transcript structures, and the applicability of each depends on the use case. To support the analyst in asking a broad range of questions, there is a need for a mechanism that draws from a data source of gene annotations and returns them in a variety of different data models. The GenomicFeatures package fills that role by distilling multiple data sources into a single database schema and wrapping that database in an API that returns, for example, the exons grouped by gene, or the bounds for every transcript. The databases are implemented in SQLite and are thus accessible from environments outside of R. For reproducibility, a database may be encapsulated in a redistributable R package.The database is represented by the TranscriptDb class and stores the range of each exon, the coding range, the transcript ID, the gene ID, and metadata about the source of the transcript information. The GenomicFeatures package provides an automated mechanism for constructing a TranscriptDb object from tracks defined in the UCSC genome browser, Biomart, or GTF/GFF files. Bioconductor provides pre-built packages for the most widely adopted gene models, like the UCSC known gene annotations on hg19. These packages follow a standard naming convention, e.g., TxDb.Hsapiens.UCSC.hg19.knownGene.There are functions for performing common queries that return the exons, coding regions, and transcript boundaries as a GRanges object. Transcript and gene-level groupings are preserved by GRangesList objects. The ranges in Figure 1 were derived from the TxDb.Hsapiens.UCSC.hg19.knownGene package using the following call to the function exons:\n\n> library(\u201cTxDb.Hsapiens.UCSC.hg19.knownGene\u201d)\n\n> library(\u201corg.Hs.eg.db\u201d)\n\n> kras_gene <- org.Hs.egSYMBOL2EG$KRAS\n\n> kras_exons <- exons(TxDb.Hsapiens.UCSC.hg19.knownGene,\n\n+ vals \u200a=\u200a list(gene_id \u200a=\u200a kras_gene),\n\n+ columns \u200a=\u200a c(\u201ctx_id\u201d, \u201cexon_id\u201d))\nTo retrieve the exons corresponding to a particular transcript, such as transcript 48666 of KRAS, we call exonsBy, which returns a GRangesList of exons grouped by transcript, and extract the element corresponding to the desired transcript identifier:\n> exonsByTx <- exonsBy(TxDb.Hsapiens.UCSC.hg19.knownGene)\n\n> krasA <- exonsByTx[[\u201c48666\u201d]]\nThe contents of krasA are shown in Table 2.Table 2Contents of the krasA object, representing the exons in isoform A of KRAS.\nGRanges with 5 ranges and 3 metadata columns:\n\nseqnames\n\nranges\n\nstrand\n\n|\n\nexon_id\n\nexon_name\n\nexon_rank\n\n[1]\n\nchr13\n\n[106118565, 106118681]\n\n+\n\n|\n\n174810\n\n<NA>\n\n1\n\n[2]\n\nchr13\n\n[106119356, 106119490]\n\n+\n\n|\n\n174811\n\n<NA>\n\n2\n\n[3]\n\nchr13\n\n[106124887, 106125034]\n\n+\n\n|\n\n174814\n\n<NA>\n\n3\n\n[4]\n\nchr13\n\n[106142141, 106142541]\n\n+\n\n|\n\n174818\n\n<NA>\n\n4\n\n[5]\n\nchr13\n\n[106143261, 106143383]\n\n+\n\n|\n\n174820\n\n<NA>\n\n5\nOpen in a separate windowAssociating Annotations with Ranges\nFigure 1 demonstrates how genomic data consist of both ranges and uni- or multivariate annotations on those ranges. In that table, the annotations are the exon ID and a variable grouping the exons into transcripts. If we had read alignments from an RNA-seq experiment, we might use countOverlaps to generate a read count for each exon. Other examples of annotation would include the reference and alternate bases for a single nucleotide variant (SNV) or the position weight matrix (PWM) score for a putative transcription factor binding site.Every multi-element data structure in the IRanges suite supports the storage of per-element metadata: data about data. In this case, the metadata are the annotations, and the primary data are the ranges being annotated. This includes all of the data structures for storing ranges, such as IRanges, GRanges and GRangesList. The metadata are stored in a DataFrame with as many rows as there are elements in the object. We introduce a DataFrame class that behaves similarly to the base R data.frame, but supports storage of complex vector-like objects (e.g., a DNAStringSet, representing DNA sequences, or a GRanges) in columns.Working with Coverage and Similar VectorsA common method of summarizing a genomic data set is to calculate the coverage, i.e., the number of features in the data set overlapping each position in the genome. This is useful in ChIP-seq analysis, where many peak detection methods operate on the coverage.For this example, mouse genomic DNA was cross-linked with DNA-binding proteins, fragmented and precipitated with an antibody for CTCF. An antibody for GFP was used for the control. The CTCF and GFP samples were each sequenced in a single lane on an Illumina sequencer, which generated reads 35 nt in length [6]. We excluded the last 11 nt of each read due to insufficient quality, so the effective read length was 24 nt. The reads were aligned to the mm9 build of the mouse genome using MAQ. We parsed the MAQ output using the ShortRead package [7], and the alignments for three chromosomes (chr10, chr11 and chr12) were extracted for use as a demonstration data set in the chipseq package [8].\n> library(\u201cchipseq\u201d)\n\n> data(\u201ccstest\u201d)\n\n> ctcfReads <- cstest$ctcf\nThe ctcfReads object, listed in Table 3, is a GRanges holding the read alignments from the CTCF sample. The GRanges stores the chromosome names, ranges, and strand for each alignment, as well as a list of chromosome names and lengths for the mm9 genome. Tracking the chromosome information guards against errors that could arise, for example, from mixing data across genome assemblies.Table 3Ranges for the first three reads in the ctcfReads object, storing the read alignments for the CTCF sample.\nGRanges with 3 ranges and 0 metadata columns:\n\nseqnames\n\nranges\n\nstrand\n\n[1]\n\nchr10\n\n[3012936, 3012959]\n\n+\n\n[2]\n\nchr10\n\n[3012941, 3012964]\n\n+\n\n[3]\n\nchr10\n\n[3012944, 3012967]\n\n+\nOpen in a separate windowEach read represents only 24 nt from one end of a fragment of DNA. Since it was the fragment, but not necessarily the sequenced region, that was cross-linked to CTCF, we need to consider the entire fragment when predicting binding sites. We assume that the fragment length was approximately 120 nt and call resize to extend our read ranges to fragment-sized ranges:\n> ctcfFragments <- resize(ctcfReads, 120)\nNote that the strand of the alignment was automatically taken into account.The coverage function calculates the coverage for a set of ranges. We calculate the coverage on the CTCF fragments from our ChIP-seq data set as follows:\n> ctcfCoverage <- coverage(ctcfFragments)\n\n> ctcfCoverage10 <- ctcfCoverage$chr10\nThe ctcfCoverage object is a list, with one coverage vector per chromosome. For simplicity, we extract the element corresponding to \u201cchr10\u201d. The ctcfCoverage10 object is of class Rle.Vectors along the genome tend to have many repeated values. For the sake of compactness, we compress the data using a run-length encoding compression scheme. Through the R class system, we abstract this efficient implementation behind an API that supports the features of ordinary R vectors; the complexity is hidden from the user. The Rle class represents a run-length encoded vector and provides features beyond those of ordinary vectors. For example, one can use ranges to extract values from an Rle. This integrates range-based datasets with data in chromosome-length vectors. To demonstrate, we find the position of the maximum coverage on chr10, and, in order to display the coverage in context, we extract a 5000 nt region centered around that position:\n> maxPos <- which.max(ctcfCoverage10)\n\n> roi <- resize(IRanges(maxPos, width\u200a=\u200a1), 5000, \u201ccenter\u201d)\n\n> roiCoverage <- ctcfCoverage$chr10[roi]\nThe roiCoverage vector is plotted in Figure 5 and shows how the coverage relates to the gene context.Open in a separate windowFigure 5Visualization of the coverage of bases by GFP- and CTCF-bound fragments (top) in the context of part of the gene model for Rrp1, Entrez gene 18114 (bottom).Next, we wish to find peaks in the coverage vector by slicing it at a fixed threshold. We call the slice function and pass it a cutoff of 8:\n> ctcfPeaks <- slice(ctcfCoverage10, lower \u200a=\u200a 8)\nThe resulting coverage slices are ranges and and we rely on our data structures for managing and manipulating them. In particular, the ctcfPeaks object is a Views object, which combines the peak ranges with the original Rle coverage vector (another example of integrating ranges with vectors). Views has several utilities for summarizing the vector values within each range. We use these to summarize the coverage values within each peak:\n> ctcfMaxs <- viewMaxs(ctcfPeaks)\n\n> ctcfSums <- viewSums(ctcfPeaks)\nAccessing Read AlignmentsRead alignments may be loaded from a BAM file as a GappedAlignments or GappedAlignmentPairs object, depending on whether the reads should be treated as paired. Both data structures store short read alignment results in terms of the position, chromosome, strand, CIGAR string (a compact representation of the gaps) and other information. Both also support some of the range operations and can be coerced to GRanges and GRangesList. The GRanges representation holds the ungapped extents of the read alignments, whereas the GRangesList represents the alignments as ranges with gaps, including the inter-read gap of a pair and the skipped regions in the reference (e.g., introns). The choice of data structure depends on, for example, whether one wants to count the overlapping pairs, reads, or aligned segments separated by gaps.A frequent goal of RNA-seq experiments is to estimate the levels of gene expression. For this demonstration, we will simply count the number of read alignments overlapping the exonic regions of each transcript. We begin by loading a BAM file of read alignments from an RNA-seq experiment in yeast [9]. There are four samples, two of which are wildtype and two of which are RLP mutants. The leeBamViews package provides the alignments on chromosome XIII from positions 800000 to 900000.\n> bams <- getBamsFromLeeBamViews()\n\n> ga <- readGappedAlignments(bams\n[1]\n)\n\n> reads <- grglist(ga)\nThe readGappedAlignments function loads the BAM file as a GappedAlignments object, which is then coerced to a GRangesList , where each read consists of one or more ranges, separated by intronic gaps.In the next step, we obtain the transcript annotations for yeast. Bioconductor provides a TranscriptDb object for the UCSC sacCer2 assembly, and we extract from it a GRangesList representing the transcripts, by calling exonsBy. In order to detect overlaps, the alignments and gene annotations need to have the same chromosome names; we correct for that with the calls to keepSeqlevels and renameSeqlevels.\n> library(\u201cTxDb.Scerevisiae.UCSC.sacCer2.sgdGene\u201d)\n\n> tx <- exonsBy(TxDb.Scerevisiae.UCSC.sacCer2.sgdGene)\n\n> tx <- renameSeqlevels(keepSeqlevels(tx, \u201cchrXIII\u201d),\n\n+ c(chrXIII \u200a=\u200a \u201cScchr13\u201d))\nNow that the data and annotations have been loaded, we count the number of read alignments in each genomic feature:\n> counts <- countOverlaps(tx, reads, ignore.strand \u200a=\u200a TRUE)\nMore complex counting algorithms are available via the summarizeOverlaps function, which counts over multiple samples and returns the results as a SummarizedExperiment object. Unlike the call to countOverlaps above, reads that map to multiple features are discarded.Summarized ExperimentsThe typical workflow in a genomic data analysis is to reduce a complex raw data set, such as a set of RNA-seq read alignments, to a set of summaries, such as the number of reads aligned over each transcript or exon. Analogously, an exome-seq experiment yields variant calls at particular genomic ranges. It is often appropriate and convenient to store these summaries as a matrix, where the rows correspond to genes or some other genomic feature and the columns to samples. The SummarizedExperiment class is designed to hold such values, along with annotations on the genomic regions, the samples and the experiment as a whole. Its design follows the same pattern as the ExpressionSet in the Bioconductor microarray infrastructure; the primary difference is that SummarizedExperiment is based on IRanges data structures. A SummarizedExperiment may be constructed directly or generated by a function that executes a high-level workflow. For example, for a list of BAM files, the summarizeOverlaps function counts the overlaps between the read alignments and a database of transcripts. ResultsIn this section we describe range-based integrative computations related to the genetics of protein-DNA binding, and conclude with a topically organized list of Bioconductor packages that make essential use of the ranges infrastructure.Exploring Genetics of CTCF BindingIn the murine ChIP-seq example discussed previously, the ranges infrastructure was used to compute and display variation in read coverage over the mouse genome. In this example, we use tools based on the ranges infrastructure to examine both coverage and content of reads from a larger ChIP-seq experiment on human cell lines. Our basic intent is to show how the infrastructure can be used to evaluate the roles of genotype and genetic diversity in the genomic sequences where CTCF is reported to bind, with an understanding that ultimate inferences on protein binding locations and on base-call distributions over heterozygous loci will need to directly incorporate risks of base calling and read mapping errors, and will need to be followed up with wet-lab validation.For an investigation of the prevalence of allele-specific protein-DNA binding [10], BAM files on 22 ChIP-seq experiments addressing CTCF binding to DNA from immortalized B-cells were collected from the ENCODE project portal. Exclusion of files with aberrant quality score distributions left 16 BAM files corresponding to 12 distinct individuals; two technical replicates were available for each of four individuals. Furthermore, different base-call quality score scales were used for two batches of samples; by subtracting 31 from the reported mean quality scores for one set of samples, approximately identical medians and interquartile ranges were established for mean quality scores for all retained samples. Base calls for reads bound at all genomic locations with positive coverage were tabulated using the VariantTools\ntallyVariants function, and reduced to locations exhibiting statistical evidence of allele-dependent CTCF binding using the callVariants function. Each of these variant assessment tools makes use of infrastructure derived from GSNAP [11] with key results materialized as GRanges instances. Table 4 depicts an excerpt from a callVariants output.Table 4Partial output of countVariants applied to a BAM file from an ENCODE CTCF ChIP-seq experiment.\nGRanges with 8 ranges and 5 metadata columns:\n\nseqnames\n\nranges strand\n\n|\n\nref\n\nalt\n\nncycles\n\ncount\n\ncount.ref\n\nNA06990_2\n\nchr1\n\n[11391, 11391]\n\n+\n\n|\n\nT\n\nA\n\n7\n\n19\n\n5\n\nNA06990_2\n\nchr1\n\n[793522, 793522]\n\n+\n\n|\n\nT\n\nA\n\n1\n\n4\n\n10\n\nNA06990_2\n\nchr1\n\n[825860, 825860]\n\n+\n\n|\n\nG\n\nA\n\n1\n\n4\n\n5\n\nNA06990_2\n\nchr1\n\n[968600, 968600]\n\n+\n\n|\n\nA\n\nC\n\n2\n\n5\n\n6\n\nNA06990_2\n\nchr1\n\n[1057713, 1057713]\n\n+\n\n|\n\nA\n\nC\n\n3\n\n4\n\n19\n\nNA06990_2\n\nchr1\n\n[1376423, 1376423]\n\n+\n\n|\n\nG\n\nC\n\n5\n\n5\n\n53\n\nNA06990_2\n\nchr1\n\n[1376430, 1376430]\n\n+\n\n|\n\nT\n\nC\n\n4\n\n4\n\n51\n\nNA06990_2\n\nchr1\n\n[1610542, 1610542]\n\n+\n\n|\n\nA\n\nC\n\n4\n\n4\n\n28\nOpen in a separate windowThe GRanges instance includes location-specific information on 24 attributes of each call, including information on sequencer cycle, base call quality distribution, and other features of BAM-based variant calling as performed by GSNAP [11].The genome-wide searches for allele-dependent CTCF binding events employed default settings for variant calling by VariantTools\ncallVariants, which include criteria on minimum coverage, minimum diversity of read cycles at which base is found, and limitation of risk of strand bias. This process yielded a total of 19655 locations with evidence of allele-dependent CTCF binding, corresponding to 50750 events over the 12 individuals. We obtained GRanges representations of dbSNP build 137 with the scanVcf function of the VariantAnnotation. This facilitated distributed computation for partitioning allele-dependent CTCF binding events into 12691 coincident with known polymorphisms and 6964 at locations where no SNP has been reported in dbSNP.Allelic imbalance in CTCF binding corresponds to departure of the alternate nucleotide proportion (ANP) at a CTCF binding site from 50%. The upper panels of Figure 6 show the distributions of ANP stratified by coincidence of allele-dependent CTCF binding locations with locations of known SNP. The lower panels show identically stratified associations between ANP and mean base-call qualities for pileups over the allele-dependent binding locations. While the off-SNP locations show a proponderance of ANP below 20%, there is also an indication that base-call quality for such binding events is relatively low, implying that these findings would be unlikely to replicate. For example, among on-SNP allele-dependent binding calls with ANP below 20%, 5% had mean quality less than 5; the corresponding frequency for low-quality on-SNP allele-dependent binding locations calls was 41%.Open in a separate windowFigure 6Top panels: distributions of alternate nucleotide proportions for on- and off-SNP allele-dependent CTCF binding events. Bottom panels: relationships between average call quality values and alternate nucleotide proportions are depicted using a 2D density estimate (darker regions correspond to higher density.).\nFigure 6 was constructed using the packages and features described above with very little programming effort needed to specialize the computations to this example. Most computational biologists and other interested investigators could easily carry out these steps. We can conclude that allelic imbalance in CTCF binding events is frequently detectable but, for the data considered, the apparent imbalances observed are likely a mix of real biology and technical artifacts originating from, e.g., sequencing and read mapping errors. Careful analysis of metadata collected in the variant-calling process may help to disentangle the key factors contributing to allele-dependent CTCF binding.Software Based on the InfrastructureThere is a growing ecosystem of packages based on this infrastructure. By current count, more than 80 packages depend directly on the packages presented here. This includes packages for input and output of ranges ( rtracklayer , Rsamtools ) [12], [13], quality assessment ( ShortRead ) [7], sequence analysis ( Biostrings ) [14], variant calling ( VariantTools ) [15], and other tasks. To summarize the different use cases addressed by dependent packages, Table 5 tabulates the descriptive labels chosen from a controlled vocabulary by the package authors.Table 5Selected packages based on the Ranges infrastructure.TermCountExample packagesGenetics16NarrowPeaks, nucleR, GenomicFeatures, mosaicsPreprocessing11MEDIPS, biovizBase, TSSi, HMMcopyInfrastructure9Genominator, nnotationDbi, ggbio, dInfoBuilderGeneExpression8GGtools, easyRNASeq, Repitools, TransViewSequencing5girafe, triform, seqbias, rSFFreaderMicroarray4methyAnalysis, Gviz, MinimumDistance, charmClustering4chroGPS, methVisual, DirichletMultinomial, PICSGenomicSequence3rGADEM, MotifDb, MotIVQualityControl3ShortRead, R453Plus1Toolbox, htSeqToolsStatistics2oneChannelGUI, PINGOneChannel2xmapcore, annmapDataRepresentation2genoset, FunciSNPGeneticVariability2VanillaICE, SNPchipBioinformatics2DiffBind, segmentSeqChIPseq2chipseq, BayesPeakOther10ChromHeatMap, gwascat, ChIPpeakAnno, OTUbaseOpen in a separate windowCategories are biocViews terms. Up to 4 packages were randomly sampled from Bioconductor packages that explicitly declare a dependence on IRanges, GenomicRanges, or GenomicFeatures packages. Availability and Future DirectionsAll of the packages described, including IRanges, GenomicRanges and GenomicFeatures, form the core infrastructure for sequence analysis in Bioconductor and are available from the project website: http://bioconductor.org (see also Software S1-S3). We aim to continue to support scientists in their drive to further science by asking increasingly complex and integrative questions about increasingly complex and heterogeneous data. For example, we are working towards better support for detecting alternative and novel splicing, measuring isoform-specific expression, annotating sequence variants, mapping between genome, transcript and protein coordinate spaces, and integrating transcript annotations with gene-level metadata. There is also an unmet need in the visualization of genomic ranges. In particular, we need better visualizations for relating RNA-seq coverage and junction counts to transcript structures, and for diagnosing read alignments in the context of variant calling. Finally, as datasets continue to expand in size, we continue to seek more efficient algorithms and data structures, and we are vigilant for opportunities to leverage parallel computing. Supporting InformationSoftware S1\nThe IRanges package. The IRanges package provides efficient low-level and reusable S4 classes for storing and manipulating ranges of integers and compressed, genome-length vectors.(GZ)Click here for additional data file.(678K, gz)Software S2\nThe GenomicRanges package. The GenomicRanges package defines general purpose containers for storing genomic ranges as well as more specialized containers for storing alignments against a reference genome.(GZ)Click here for additional data file.(2.4M, gz)Software S3\nThe GenomicFeatures package. The GenomicFeatures package is a set of tools and methods for making and manipulating transcript-centric annotations.(GZ)Click here for additional data file.(731K, gz) Funding StatementThis work was funded by the National Institutes of Health, National Human Genome Research Group through grants P41 HG004059 and U41 HG004059 and (for VJC) by National Heart, Lung and Blood Institute grants R01 HL086601, R01 HL093076 and R01 HL094635. The funders had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript. References1. \nGentleman RC, Carey VJ, Bates DM, et al. (2004) Bioconductor: Open software development for computational biology and bioinformatics. Genome Biology\n5: R80. [PMC free article] [PubMed] [Google Scholar]2. \nQuinlan AR, Hall IM (2010) BEDTools: a exible suite of utilities for comparing genomic features. Bioinformatics\n26: 841\u2013842. [PMC free article] [PubMed] [Google Scholar]3. \nJi H, Jiang H, Ma W, Johnson DS, Myers RM, et al. (2008) An integrated software system for analyzing ChIP-chip and ChIP-seq data. Nature Biotechnology\n26: 1293\u20131300. [PMC free article] [PubMed] [Google Scholar]4. Cormen TH, Leiserson CE, Rivest RL, Stein C (2001) Introduction to algorithms. Cambridge, Mass: MIT Press.5. \nAllen JF (1983) Maintaining knowledge about temporal intervals. Communications of the ACM\n26: 832\u2013843. [Google Scholar]6. \nLi H, Ruan J, Durbin R (2008) Mapping short DNA sequencing reads and calling variants using mapping quality scores. Genome Research\n18: 1851\u20138. [PMC free article] [PubMed] [Google Scholar]7. \nMorgan M, Anders S, Lawrence M, Aboyoun P, Pagues H, et al. (2009) ShortRead: a Bioconductor package for input, quality assessment and exploration of high-throughput sequence data. Bioinformatics\n25: 2607\u20132608. [PMC free article] [PubMed] [Google Scholar]8. Sarkar D, Gentleman R, Lawrence M, Yao Z (2013) chipseq: A package for analyzing ChIP-seq data. R package version 1.10.1. Available: http://www.bioconductor.org/packages/2.12/bioc/html/chipseq.html.9. \nLee A, Hansen KD, Bullard J, Dudoit S, Sherlock G (2008) Novel low abundance and transient RNAs in yeast revealed by tiling microarrays and ultra high-throughput sequencing are not con-served across closely related yeast species. PLoS Genet\n4: e1000299. [PMC free article] [PubMed] [Google Scholar]10. \nMcDaniell R, Lee BK, Song L, Liu Z, Boyle AP, et al. (2010) Heritable individual-specific and allele-specific chromatin signatures in humans. Science\n328: 235\u20139. [PMC free article] [PubMed] [Google Scholar]11. \nWu TD, Nacu S (2010) Fast and SNP-tolerant detection of complex variants and splicing in short reads. Bioinformatics (Oxford, England)\n26: 873\u201381. [PMC free article] [PubMed] [Google Scholar]12. \nLawrence M, Gentleman R, Carey V (2009) rtracklayer: an R package for interfacing with genome browsers. Bioinformatics\n25: 1841\u20131842. [PMC free article] [PubMed] [Google Scholar]13. Morgan M, Pages H (2013) Rsamtools: Binary alignment (BAM), variant call (BCF), or tabix file import. R package version 1.12.3. Available: http://www.bioconductor.org/packages/2.12/bioc/html/Rsamtools.html.14. Pag\u00e8s H, Aboyoun P, Gentleman R, DebRoy S (2013) Biostrings: String objects representing biological sequences, and matching algorithms. R package version 2.28.0. Available: http://www.bioconductor.org/packages/2.12/bioc/html/Biostrings.html.15. Lawrence M, Degenhardt J, Gentleman R (2013) Variant-Tools: Tools for Working with Genetic Variants. R package version 1.2.2. Available: http://www.bioconductor.org/packages/2.12/bioc/html/VariantTools.html."}